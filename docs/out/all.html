<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>WAAX.DOC</title>

    <link type="text/css" rel="stylesheet" href="assets/css/reset.css">
    <link type="text/css" rel="stylesheet" href="http://yandex.st/highlightjs/6.1/styles/sunburst.min.css">
    <link type="text/css" rel="stylesheet" href="assets/css/docs.css">
    <link type="text/css" rel="stylesheet" href="assets/css/print.css" media="print">
    <link type="text/css" rel="stylesheet" href="src/waax-doc-base.css">

    <script type="text/javascript" src="assets/js/jquery-1.10.1.min.js"></script>
    <script type="text/javascript" src="http://yandex.st/highlightjs/6.1/highlight.min.js"></script>
    <script type="text/javascript" src="assets/js/lunr.min.js"></script>

    

    <script type="text/javascript">var BASE_URL = "";</script>
    <script type="text/javascript" src="assets/js/viewer.js"></script>

    
</head>
<body>
    <div id="page">
        <a name="top" />
        <header id="header">
            <h1><a href="">WAAX.DOC</a></h1>
        </header>
        

<div id="sidebar">
    <form action="search.html"><input id="search" type="text" placeholder="Search" name="q" /></form>
    <nav id="toc">
        
    <ol>
    
        <li>
            <a href="what-is-waax.html#what-is-waax">What is WAAX?</a>
            
        </li>
    
        <li>
            <a href="getting-started.html#getting-started">Getting Started</a>
            
        </li>
    
        <li>
            <a href="parameter-control.html#parameter-control">Parameter Control</a>
            
        </li>
    
        <li>
            <a href="mui.html#mui-musical-user-interface">MUI (Musical User Interface)</a>
            
        </li>
    
        <li>
            <a href="midi.html#using-midi">Using MIDI</a>
            
        </li>
    
        <li>
            <a href="unit-reference.html#unit-reference">Unit Reference</a>
            
        </li>
    
        <li>
            <a href="license-and-acknowledgement.html#license-acknowledgement">License &amp; Acknowledgement</a>
            
        </li>
    
</ol>

    </nav>
    
    <nav id="links">
        <ul>
            
        </ul>
    </nav>
    
</div>

        <div id="content">
            <a name="what-is-waax"></a><h1>What is WAAX?</h1>
<a name="introduction"></a><h2>Introduction</h2>
<p>WAAX (Web Audio API eXtension) is a JavaScript library built on top of Web Audio/MIDI API to facilitate audio programming on Blink-based web browsers - <em>Chrome, Chrome Canary and Chromium</em>.</p>
<p>Although Web Audio API provides web devlopers with the unprecedent ability to generate sound on the web browser without additional plug-ins, building a full-blown music application with it still requires vast experience in digital audio, sound synthesis and even acoustics.</p>
<p>Secondly, an audio programmer who is not familiar with the recent web techonologies will be lost in the workflow of web development spending a fair amount time to establish the environment to work on.</p>
<p>The ultimate goal of this project is to fill the gap between two opposite ends:  helping web developers to create music software without the expertise on sound synthesis and signal processing, and offering an instant boilerplate for rapid development of web-based applications to audio programmers.</p>
<a name="features"></a><h2>Features</h2>
<ul>
<li>Unit: production-ready sound generators, processors and visualizers</li>
<li>Terse and flexible API design</li>
<li>MUI (Musical User Interface) elements powered by Polymer</li>
<li>Tight integration with Web MIDI API</li>
<li>Demos, examples and documentation</li>
</ul>
<a name="cross-browser-support-as-of-92013"></a><h2>Cross-Browser Support <small>(as of 9.2013)</small></h2>
<p><strong>Web Audio API</strong>: currently WAAX only supports Blink-based browsers (Chrome, Chrome Canary, and Chromium). Except for IE, supporting all the major web browsers is a top prirority on the roadmap of this project. Polyfills for Safari and FireFox will be patched up in the near future.</p>
<p><strong>Web MIDI API</strong>: Chromium and Chrome Canary (31+) on OSX are the only web browsers that support the native MIDI I/O. It will take a while until it lands on Chrome stable and the support from Safari and FireFox is not clear at the moment.</p>
<a name="cross-platform-support-as-of-92013"></a><h2>Cross-Platform Support <small>(as of 9.2013)</small></h2>
<p>The audio/MIDI subsystem on different platforms significantly varies. Thanks to CoreAudio and CoreMIDI, the current implementation of Blink-based browsers on OSX uses 128 samples of audio buffer size (with the expected latency around 3ms, fixed and non-user-configurable) and it also comes with the solid support on Web MIDI API on Chrome Canary.</p>
<p>On the other hand, the land of Windows, Linux and Android will suffer from several issues: high latency, buffer underun over time, and no love on MIDI support. This is simply because these platforms do not provide a viable audio/MIDI subsystem for optimum performance. For cross-platform isseus, please leave your feedback on the WAAX wiki on GitHub.</p>

<a name="getting-started"></a><h1>Getting Started</h1>
<a name="installation"></a><h2>Installation</h2>
<p>For the local developement, you can download the zipped file or clone the GitHub repository.</p>
<pre><code>$ git clone https://github.com/hoch/WAAX.git</code></pre>
<a name="using-waax-in-html-document"></a><h2>Using WAAX in HTML Document</h2>
<p>If you are simply using the minified library (core + reference units), include library files from the URL below.</p>
<pre><code>&lt;script src=&quot;http://waax-static.appspot.com/build/WAAX.min.js&quot;&gt;&lt;/script&gt;</code></pre>
<p>Alternatively, you can choose files you want to use. Note that the core library  and Fader plug-in must be loaded first before you can use any WAAX units. The example below loads the definition of oscillator unit after the WAAX core and Fader.</p>
<pre><code>&lt;script src=&quot;your_path/WAAX.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;your_path/Fader.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;your_path/Oscil.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  // your WAAX code here...
&lt;/script&gt;</code></pre>
<p>The reference list of units can be found in this doucmentation. Once you&#39;ve done with the developelment, you can compile the core and unit JavaScript files into a single file with your favorite tool chains.</p>
<a name="hello-sine"></a><h2>&quot;Hello Sine!&quot;</h2>
<pre><code class="lang-javascript">var sine = WX.Oscil({ pGain: 0.25 });
sine.to(WX.Master);</code></pre>
<p>In the code example above, a sine oscillator is being created and connected to the master output of WAAX system. The oscillator (<code>sine</code>) or the master output (<code>WX.Master</code>) is called <strong>&#39;WAAX Unit&#39;</strong> or <strong>&#39;unit&#39;</strong> for short. Note that there is no <em>new</em> keyword for unit construction. <code>WX.Oscil()</code> is a factory method that produces an instance of oscillator with the initial setting, the gain of 0.25 in this case. The <code>.to()</code> method connects the oscillator and the master output.</p>
<a name="making-connections"></a><h2>Making Connections</h2>
<p>The <code>.to()</code> method can be chained to connect more than 3 units. Also it might be useful to know <code>WX.patch()</code> method when connecting several units at once. As shown previously, you can intialize WAAX unit by passing an object of parameters to its factory method.</p>
<pre><code>var noise = WX.Noise({ pGain: 0.5 }),
    lpf = WX.LPF({ pCutoff: 250, pQ: 12 });
noise.to(lpf).to(WX.Master);
WX.patch(noise, lpf, WX.Master);</code></pre>
<p>There we just built our first <em>audiographs</em> with WAAX. Try this example here!</p>

<a name="parameter-control"></a><h1>Parameter Control</h1>
<p>Having a complete control on parameters is crucial in sound synthesis. It gives you the ability to create more complex and interesting sound. With that in mind, WAAX is carefully designed to offer the ease of control with maximum flexibilty.</p>
<a name="tweaking-parameters"></a><h2>Tweaking Parameters</h2>
<p>Every WAAX unit has a <code>.params</code> object, that includes all the available parameters that user can tweak. It is fairly similar to <code>AudioParam</code> object from Web Audio API and it is an abstract layer for <code>AudioParam</code> with more simple syntax and other neat features such as saving/loading presets or easy binding to GUI widgets. The unit reference documentation contains detailed information on the unit-specific parameters.</p>
<pre><code>var osc = WX.Oscil({ pFreq: 440.0 });
osc.set(&#39;pGain&#39;, 0.25);
osc.to(WX.Master);</code></pre>
<p>The <code>.set()</code> method in WAAX is designed for comprehensive parameter control. This method makes it possible to apply the unified parameter control across all the WAAX units. As shown above, the <code>.set()</code> method requires <strong>parameter name</strong> and <strong>value</strong> to do the job.</p>
<p>Note that WAAX parameters start with the lowercase <em>p</em> such as <code>pGain</code> and <code>pFreq</code>. It indicates the variable is a parameter that you can <em>set, automate, link, and bind</em> with other elements in the WAAX system.</p>
<a name="making-transitions"></a><h2>Making Transitions</h2>
<p>The code example below will generate a sine wave with 2 seconds of fade-in and 2 seconds of fade-out. This procedure has so many names: automation, slewing, transition, ramping and so on; it is very important to avoid a sudden change on parameters unless it is required or intended. Without proper ramping up and down, the resulting sound will suffer from clicks and pops.</p>
<pre><code class="lang-javascript">var osc = WX.Oscil({ pGain: 0.0 });
osc.to(WX.Master);
osc.set(&#39;pGain&#39;, 1.0, &#39;line&#39;, WX.now + 2.0);
osc.set(&#39;pGain&#39;, 0,0, &#39;line&#39;, WX.now + 4.0);</code></pre>
<p>As shown above, you can add 3 more arguments to achieve time-related tasks. (In this case it uses 2 more arguments, transition type and end time) In addition, the <code>.set()</code> method is using <code>WX.now</code> variable because we need to specify the temporal structure of this transition. Note that <code>WX.now</code> always returns the elapsed time in seconds since the audio context of the page started.</p>
<a name="modulation"></a><h2>Modulation</h2>
<p>To make a long story <em>very</em> short, the modulation is modifying a signal with the other signal. In Web Audio API, you can change a parameter automatically and programmtically by connecting a signal to the parameter. Usually a synthesizer has a complex routing table for modulation and it is often called a modulation matrix.</p>
<pre><code>var osc = WX.Oscil({ pGain: 0.0 }),
    lfo = WX.Oscil({ pFreq: 1.0, Gain: 0.5 });
lfo.modulate(osc, &#39;pGain&#39;);</code></pre>
<p>In the example above, we have the oscillator <code>lfo</code> modulate the gain of the <code>osc</code> unit to accomplish amplitude modulation (AM). Behind the scene, the <code>.modulate()</code> method looks for available modulation targets in the <code>osc</code> unit, and create the modulation route with the parameter named &#39;pGain.&#39;</p>
<p>Not all parameters are modulatable. The information on modulation target on each unit can be found on the unit reference documentation. For more advanced modulation, please have a look at the tutorial on modulation.</p>
<a name="saving-and-loading-presets"></a><h2>Saving and Loading Presets</h2>
<p>Every unit in WAAX has two methods in common: <code>.getParams()</code> and <code>.setParams()</code>. By using these methods, you can retrieve or set the current parameters in unit. They are useful when you are saving whole paramemters for multiple units as a preset.</p>
<pre><code>var params = osc.getParams();
osc.setParams(params);</code></pre>
<p>Note that the method <code>.getParams()</code> returns a new (cloned) object, not the reference of parameter object in the unit.</p>

<a name="mui-musical-user-interface"></a><h1>MUI (Musical User Interface)</h1>
<p>MUI is a collection of custom HTML elements that are specifically disigned for musical applications.</p>
<a name="installation"></a><h2>Installation</h2>
<p>Since MUI is a part of WAAX, so no additional installation is necessary if you have already installed the WAAX by cloning the repository or downloading the files. MUI elements are built on top of <a href="http://www.polymer-project.org/">Polymer</a> and it is already included in the MUI directory.</p>
<a name="loading-mui-in-html-document"></a><h2>Loading MUI in HTML document</h2>
<p>Currently activating MUI needs a bit more work. (It will be fixed soon.) First off, Polymer library must be loaded first and then MUI core and its style sheet should come next.</p>
<pre><code class="lang-html">&lt;script src=&quot;lib/polymer.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;mui-core.js&quot;&gt;&lt;/script&gt;
&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mui-core.css&quot;&gt;</code></pre>
<p>Once the bootstrap is loaded, you can selectively start loading MUI elements (GUI widgets) you wish to use on the document. The following example shows how to import the knob and the toggle switch.</p>
<pre><code class="lang-html">&lt;link rel=&quot;import&quot; href=&quot;elements/mui-knob.html&quot;&gt;
&lt;link rel=&quot;import&quot; href=&quot;elements/mui-toggle.html&quot;&gt;</code></pre>
<a name="using-mui-elements"></a><h2>Using MUI elements</h2>
<p>Here is the fun part. You can create knobs and toggles switches by simply writing  HTML codes below. They are called &quot;custom elements&quot; which is made possible by Polymer; highly-componentized, portable, and reusable GUI widgets specifically designed for WAAX unit.</p>
<pre><code class="lang-html">&lt;mui-toggle id=&quot;kActive&quot; label=&quot;ON&quot;&gt;&lt;/mui-toggle&gt;
&lt;mui-knob id=&quot;kFreq&quot; label=&quot;Frequency&quot; value=&quot;0.01&quot; min=&quot;5000&quot; max=&quot;440.0&quot;&gt;&lt;/mui-knob&gt;</code></pre>
<p>Linking the toggle switch and the knob to the oscillator is surprinsingly simple. The good news is you do not have to worry about synchronizing variables in GUI widgets, corresponding parameters in WAAX unit and even values in the abstracted Web Audio API node.</p>
<pre><code class="lang-javascript">var osc = WX.Oscil();
MUI.$(&#39;kActive&#39;).link(osc, &#39;pActive&#39;);
MUI.$(&#39;kFreq&#39;).link(osc, &#39;pFreq&#39;);</code></pre>
<p>You can select a MUI element by using the special selector <code>MUI.$()</code>. Each MUI element has <code>.link()</code> method and the binding to a certain parameter can be done by passing the target unit reference (<code>osc</code>) and the parameter name (<code>pActive</code> or <code>pFreq</code>).</p>
<p>This auto-magical parameter binding is managed by Polymer ensuring all the values across different layers completely synchronized. That means the value in the oscillator will be changed when you touch the knob, and also the knob position will be changed when you modify the parameter value of the oscillator. This takes preset managment and MIDI support to another level. Truly empowering!</p>

<a name="using-midi"></a><h1>Using MIDI</h1>
<p><strong>NOTE!</strong> MIDI support in WAAX requires Web MIDI API, which is only available on Chrome Canary on OSX at the time of writing.</p>
<p>This section describes how to program MIDI functionalities in conjuntion with WAAX library. Before launching the browser, MIDI-compatible device (MIDI controller or MIDI interface) needs to be connected to the computer and the proper device driver should be installed. Otherwise you will have to restart the browser to get MIDI devices recognized.</p>
<a name="importing-midi-supprot"></a><h2>Importing MIDI Supprot</h2>
<p>If you are using the minified version of WAAX, you do not need to do anything further because the MIDI library is already enclosed. However, if you are selectivly importing WAAX components, the MIDI manager, <code>Ktrl.js</code>, should be included in the HTML document. (replace <code>waax_path</code> with the local WAAX directory.)</p>
<pre><code>&lt;script src=&quot;waax_path/Ktrl.js&quot;&gt;&lt;/script&gt;</code></pre>
<a name="creating-midi-target-and-data-handler"></a><h2>Creating MIDI Target and Data Handler</h2>
<p><code>Ktrl.js</code> offers highly flexible MIDI data routing by abstracting physical and virtual MIDI devices. In order to route MIDI data to a certain destination, a MIDI target must be created.</p>
<pre><code>var midiTarget = Ktrl.createTarget(&quot;mySynth&quot;);
midiTarget.activate();</code></pre>
<p>The next step is to design MIDI data handler for the newly created <code>midiTarget</code> instance. Use <code>.onData()</code> method to define the data handler. Programming the data handler is much easier than dealing with raw MIDI data bytes since the <code>.parse()</code> method transforms the raw data into human-readable form.</p>
<pre><code>midiTarget.onData(function (midimessage) {
  var data = Ktrl.parse(midimessage);
  switch (data.type) {
    case &quot;noteon&quot;:
      console.log(data.pitch, data.velocity);
      break;
    // more handling code...
  }
});</code></pre>
<a name="routing-midi-data"></a><h2>Routing MIDI data</h2>
<p>With the data handler, now we are ready to use the MIDI target for the incoming MIDI data. The final step of MIDI programming is routing MIDI inputs to the MIDI targets. Like the MIDI system in common digital audio workstation, <code>Ktrl.js</code> provides an aggregated input device; regardless of the number of devices connected to the system, it can be treated as a single virtual MIDI input device.</p>
<pre><code>Ktrl.ready(function () {
  Ktrl.routeAllToTarget(midiTarget);
});</code></pre>
<p>This is a safe bet for common usage since whatever MIDI device connected to the system, it will be used by the HTML document without specifying the reference of MIDI device. Alternatively, you can create individual routings as shown below.</p>
<pre><code>Ktrl.ready(function () {
  Ktrl.routeSourceToTarget(1, midiTarget);
});</code></pre>
<p>The code above demonstrates how to connect the second MIDI device to the web audio synth (MIDI target). However, if the computer does not have the second MIDI device, it will throw an error.</p>
<p>For the API reference, please visit <a href="https://github.com/hoch/Ktrl">the project page</a>.</p>

<a name="unit-reference"></a><h1>Unit Reference</h1>
<a name="unit-common-parameters-unit-base-class"></a><h3>Unit Common Parameters (Unit Base Class)</h3>
<table>
<thead>
<tr>
<th align="center">name</th>
<th align="center">type</th>
<th align="center">description</th>
<th align="center">modulatable</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>pActive</code></td>
<td align="center">boolean</td>
<td align="center">unit status (bypass on false)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>pGain</code></td>
<td align="center">float</td>
<td align="center">unit output gain</td>
<td align="center">yes</td>
</tr>
</tbody>
</table>
<a name="unit-common-methods-unit-base-class"></a><h3>Unit Common Methods (Unit Base Class)</h3>
<a name="setparamname-value"></a><h4><code>set(paramName, value)</code></h4>
<p>sets value of target parameter immediately.</p>
<ul>
<li><code>paramName</code> <em>(string)</em> target parameter name</li>
<li><code>value</code> <em>(float)</em> target value</li>
</ul>
<a name="setparamname-value-transtype-time"></a><h4><code>set(paramName, value, transType, time)</code></h4>
<p>schedules value of target parameter with specified transition and end time.</p>
<ul>
<li><code>paramName</code> <em>(string)</em> target parameter name</li>
<li><code>value</code> <em>(float)</em> target value</li>
<li><code>transType</code> <em>(int, string)</em> transition type: [1, 2, 3] or [&#39;line&#39;, &#39;expo&#39;, &#39;target&#39;]</li>
<li><code>time</code> <em>(float)</em> transition end time</li>
</ul>
<a name="setparamname-value-target-time1-time2"></a><h4><code>set(paramName, value, &quot;target&quot;, time1, time2)</code></h4>
<p>schedules value of target parameter with exponential transition between start and end time.</p>
<ul>
<li><code>paramName</code> <em>(string)</em> target parameter name</li>
<li><code>value</code> <em>(float)</em> target value</li>
<li><code>time1</code> <em>(float)</em> transition start time</li>
<li><code>time2</code> <em>(float)</em> transition end time</li>
</ul>
<a name="tounit"></a><h4><code>to(unit)</code></h4>
<p>connects to WAAX unit.</p>
<ul>
<li><code>unit</code> <em>(wxunit)</em> WAAX Unit with inlet</li>
</ul>
<a name="connectaudionode"></a><h4><code>connect(audioNode)</code></h4>
<p>connects to Web Audio API node.</p>
<ul>
<li><code>unit</code> <em>(wxunit)</em> WAAX Unit (with inlet)</li>
</ul>
<a name="modulateunit-paramname"></a><h4><code>modulate(unit, paramName)</code></h4>
<p>modulates a parameter in target WAAX unit.</p>
<ul>
<li><code>unit</code> <em>(wxunit)</em> WAAX Unit</li>
<li><code>paramName</code> <em>(string)</em> unit parameter</li>
</ul>
<a name="wxadsr"></a><h2>WX.ADSR</h2>
<p>Multi-phase envelope generator: attack, decay, sustain, release.</p>
<a name="wxadsr-parameters"></a><h3>WX.ADSR: Parameters</h3>
<table>
<thead>
<tr>
<th align="center">name</th>
<th align="center">type</th>
<th align="center">description</th>
<th align="center">modulatable</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>pAttack</code></td>
<td align="center">float</td>
<td align="center">attacking time in seconds</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>pDecay</code></td>
<td align="center">float</td>
<td align="center">decay time in seconds</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>pSustain</code></td>
<td align="center">float</td>
<td align="center">gain in sustain phase</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>pRelease</code></td>
<td align="center">float</td>
<td align="center">release time in seconds</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>pTimeConstant</code></td>
<td align="center">float</td>
<td align="center">time constant of exponential curve for release phase</td>
<td align="center"></td>
</tr>
</tbody>
</table>
<a name="wxadsr-methods"></a><h3>WX.ADSR: Methods</h3>
<a name="setadsrattack-decay-sustain-release"></a><h4><code>setADSR(attack, decay, sustain, release)</code></h4>
<ul>
<li><code>attack</code> <em>(float)</em> attack time in seconds</li>
<li><code>decay</code> <em>(float)</em> decay time in seconds</li>
<li><code>sustain</code> <em>(float)</em> gain in sustain phase</li>
<li><code>release</code> <em>(float)</em> release time in seconds</li>
</ul>
<a name="wxchorus"></a><h2>WX.Chorus</h2>
<p>Chorus effect based on <a href="https://ccrma.stanford.edu/~dattorro/EffectDesignPart2.pdf">the paper by Jon Dattorro</a>.</p>
<a name="wxchorus-parameters"></a><h3>WX.Chorus: Parameters</h3>
<table>
<thead>
<tr>
<th align="center">name</th>
<th align="center">type</th>
<th align="center">description</th>
<th align="center">modulatable</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>pRate</code></td>
<td align="center">float</td>
<td align="center">LFO speed for modulation</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>pDepth</code></td>
<td align="center">float</td>
<td align="center">LFO depth for modulation</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>pIntensity</code></td>
<td align="center">float</td>
<td align="center">internal feedback intensity</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>pBlend</code></td>
<td align="center">float</td>
<td align="center">blend amount between feedback and feedforward</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>pMix</code></td>
<td align="center">float</td>
<td align="center">mix amount between wet and dry signal</td>
<td align="center"></td>
</tr>
</tbody>
</table>
<a name="wxcomp"></a><h2>WX.Comp</h2>
<p>Compressor with variable knee setting. DynamicCompressor node in WAAX wrapper.</p>
<a name="wxcomp-parameters"></a><h3>WX.Comp: Parameters</h3>
<table>
<thead>
<tr>
<th align="center">name</th>
<th align="center">type</th>
<th align="center">description</th>
<th align="center">modulatable</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>pThreshold</code></td>
<td align="center">float</td>
<td align="center">threshold in decibles</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>pKnee</code></td>
<td align="center">float</td>
<td align="center">knee (in decibels)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>pRatio</code></td>
<td align="center">float</td>
<td align="center">compression ratio</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>pAttack</code></td>
<td align="center">float</td>
<td align="center">attack time</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>pRelease</code></td>
<td align="center">float</td>
<td align="center">release time</td>
<td align="center"></td>
</tr>
</tbody>
</table>
<a name="wxconverb"></a><h2>WX.Converb</h2>
<p>Convolution reverb with mix balance control.</p>
<a name="wxconverb-parameters"></a><h3>WX.Converb: Parameters</h3>
<table>
<thead>
<tr>
<th align="center">name</th>
<th align="center">type</th>
<th align="center">description</th>
<th align="center">modulatable</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>pMix</code></td>
<td align="center">float</td>
<td align="center">mix amount between wet and dry signal</td>
<td align="center"></td>
</tr>
</tbody>
</table>
<a name="wxconverb-methods"></a><h3>WX.Converb: Methods</h3>
<a name="setimpulseresponseimpulseresponse"></a><h4><code>setImpulseResponse(impulseResponse)</code></h4>
<ul>
<li><code>impulseResponse</code> <em>(audioBuffer)</em> impulse response buffer</li>
</ul>
<a name="wxfader"></a><h2>WX.Fader</h2>
<p>Fader abstraction. Supports muting, gain control in decibels. Note that <code>WX.Master</code> is a pre-declared instance of this unit class.</p>
<a name="wxfader-parameters"></a><h3>WX.Fader: Parameters</h3>
<table>
<thead>
<tr>
<th align="center">name</th>
<th align="center">type</th>
<th align="center">description</th>
<th align="center">modulatable</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>pMute</code></td>
<td align="center">boolean</td>
<td align="center">muted when true</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>pdB</code></td>
<td align="center">float</td>
<td align="center">gain in decibels</td>
<td align="center"></td>
</tr>
</tbody>
</table>
<a name="wxfilterbank"></a><h2>WX.FilterBank</h2>
<p>Filterbank with 16 bandpass filters. Custom design for FrostPad demo.</p>
<a name="wxfilterbank-parameters"></a><h3>WX.FilterBank: Parameters</h3>
<table>
<thead>
<tr>
<th align="center">name</th>
<th align="center">type</th>
<th align="center">description</th>
<th align="center">modulatable</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>pPitch</code></td>
<td align="center">int</td>
<td align="center">base pitch of filterbank</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>pChord</code></td>
<td align="center">string</td>
<td align="center">chord type* for harmonic structure</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>pSlope</code></td>
<td align="center">float</td>
<td align="center">gain balance between high end and low end</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>pWidth</code></td>
<td align="center">float</td>
<td align="center">bandwidth of filters</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>pDetune</code></td>
<td align="center">float</td>
<td align="center">detune of filter frequency</td>
<td align="center"></td>
</tr>
</tbody>
</table>
<ul>
<li>chord type: &#39;ionian&#39;, &#39;lydian&#39;, &#39;mixolydian&#39;, &#39;aeolian&#39;</li>
</ul>
<a name="wxfmop"></a><h2>WX.FMop</h2>
<p>FM operator consists of 2 sine oscillator.</p>
<a name="wxfmop-parameters"></a><h3>WX.FMop: Parameters</h3>
<table>
<thead>
<tr>
<th align="center">name</th>
<th align="center">type</th>
<th align="center">description</th>
<th align="center">modulatable</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>pFreq</code></td>
<td align="center">float</td>
<td align="center">frequency of carrier, related to base pitch</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>pHarmonicRatio</code></td>
<td align="center">float</td>
<td align="center">harmonic coefficient between modulator and carrier frequency</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>pModulationIndex</code></td>
<td align="center">float</td>
<td align="center">gain coefficient of modulator output</td>
<td align="center"></td>
</tr>
</tbody>
</table>
<a name="wxfmop-methods"></a><h3>WX.FMop: Methods</h3>
<a name="starttime"></a><h4><code>start(time)</code></h4>
<ul>
<li><code>time</code> <em>(float)</em> time in seconds for unit activation. optional.</li>
</ul>
<a name="stoptime"></a><h4><code>stop(time)</code></h4>
<ul>
<li><code>time</code> <em>(float)</em> time in seconds for unit deactivation. optional.</li>
</ul>
<a name="wxformantv"></a><h2>WX.FormantV</h2>
<p>Formant filter for simple vowel synthesis based on 2D vector positioning. It is heavily inspired by Ge Wang&#39;s joystick-formant demo.</p>
<a name="wxformantv-parameters"></a><h3>WX.FormantV: Parameters</h3>
<table>
<thead>
<tr>
<th align="center">name</th>
<th align="center">type</th>
<th align="center">description</th>
<th align="center">modulatable</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>pPositionX</code></td>
<td align="center">float</td>
<td align="center">x position of 2d vector</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>pPositionY</code></td>
<td align="center">float</td>
<td align="center">y position of 2d vector</td>
<td align="center"></td>
</tr>
</tbody>
</table>
<a name="wxformantv-methods"></a><h3>WX.FormantV: Methods</h3>
<a name="setpositionx-y-transtype-time1-time2"></a><h4><code>setPosition(x, y, transType, time1, time2)</code></h4>
<ul>
<li><code>x</code> <em>(float)</em> x position of 2d vector</li>
<li><code>y</code> <em>(float)</em> y position of 2d vector</li>
<li><code>transType</code> <em>(string | int)</em> additional argument for <code>.set()</code> method</li>
<li><code>time1</code> <em>(float)</em> additional argument for <code>.set()</code> method</li>
<li><code>time2</code> <em>(float)</em> additional argument for <code>.set()</code> method</li>
</ul>
<a name="wximpulsetrain"></a><h2>WX.ImpulseTrain</h2>
<p>Impulse train generator based on oscillator node.</p>
<a name="wximpulsetrain-parameters"></a><h3>WX.ImpulseTrain: Parameters</h3>
<table>
<thead>
<tr>
<th align="center">name</th>
<th align="center">type</th>
<th align="center">description</th>
<th align="center">modulatable</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>pFreq</code></td>
<td align="center">float</td>
<td align="center">frequency of impulse train</td>
<td align="center">yes</td>
</tr>
<tr>
<td align="center"><code>pDynamic</code></td>
<td align="center">boolean</td>
<td align="center">use dynamic mode</td>
<td align="center"></td>
</tr>
</tbody>
</table>
<a name="wximpulsetrain-methods"></a><h3>WX.ImpulseTrain: Methods</h3>
<a name="starttime"></a><h4><code>start(time)</code></h4>
<ul>
<li><code>time</code> <em>(float)</em> time in seconds for unit activation. optional.</li>
</ul>
<a name="stoptime"></a><h4><code>stop(time)</code></h4>
<ul>
<li><code>time</code> <em>(float)</em> time in seconds for unit deactivation. optional.</li>
</ul>
<a name="wxlpf"></a><h2>WX.LPF</h2>
<p>Low pass filter based on two biquad filter nodes. Enhanced mode will cascade two filters in serial resulting higher and narrow resonance.</p>
<a name="wxlpf-parameters"></a><h3>WX.LPF: Parameters</h3>
<table>
<thead>
<tr>
<th align="center">name</th>
<th align="center">type</th>
<th align="center">description</th>
<th align="center">modulatable</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>pCutoff</code></td>
<td align="center">float</td>
<td align="center">filter frequency</td>
<td align="center">yes</td>
</tr>
<tr>
<td align="center"><code>pQ</code></td>
<td align="center">float</td>
<td align="center">filter resonance</td>
<td align="center">yes</td>
</tr>
<tr>
<td align="center"><code>pEnhanced</code></td>
<td align="center">boolean</td>
<td align="center">enhanced mode</td>
<td align="center"></td>
</tr>
</tbody>
</table>
<a name="wxnoise"></a><h2>WX.Noise</h2>
<p>White noise (gaussian distribution) generator. The implementation is based on buffer source node to unsure the optimum performance.</p>
<a name="wxnoise-parameters"></a><h3>WX.Noise: Parameters</h3>
<table>
<thead>
<tr>
<th align="center">name</th>
<th align="center">type</th>
<th align="center">description</th>
<th align="center">modulatable</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>pGrain</code></td>
<td align="center">float</td>
<td align="center">granularity of noise</td>
<td align="center">yes</td>
</tr>
<tr>
<td align="center"><code>pDynamic</code></td>
<td align="center">boolean</td>
<td align="center">use dynamic mode</td>
<td align="center"></td>
</tr>
</tbody>
</table>
<a name="wxnoise-methods"></a><h3>WX.Noise: Methods</h3>
<a name="starttime"></a><h4><code>start(time)</code></h4>
<ul>
<li><code>time</code> <em>(float)</em> time in seconds for unit activation. optional.</li>
</ul>
<a name="stoptime"></a><h4><code>stop(time)</code></h4>
<ul>
<li><code>time</code> <em>(float)</em> time in seconds for unit deactivation. optional.</li>
</ul>
<a name="wxoscil"></a><h2>WX.Oscil</h2>
<p>Multi-waveform oscillator with gain control.</p>
<a name="wxoscil-parameters"></a><h3>WX.Oscil: Parameters</h3>
<table>
<thead>
<tr>
<th align="center">name</th>
<th align="center">type</th>
<th align="center">description</th>
<th align="center">modulatable</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>pType</code></td>
<td align="center">string</td>
<td align="center">waveform type*</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>pFreq</code></td>
<td align="center">float</td>
<td align="center">oscillator frequency</td>
<td align="center">yes</td>
</tr>
<tr>
<td align="center"><code>pDynamic</code></td>
<td align="center">boolean</td>
<td align="center">use dynamic mode</td>
<td align="center"></td>
</tr>
</tbody>
</table>
<ul>
<li>waveform type: &#39;sine&#39;, &#39;square&#39;, &#39;sawtooth&#39;, &#39;triangle&#39;</li>
</ul>
<a name="wxoscil-methods"></a><h3>WX.Oscil: Methods</h3>
<a name="starttime"></a><h4><code>start(time)</code></h4>
<ul>
<li><code>time</code> <em>(float)</em> time in seconds for unit activation. optional.</li>
</ul>
<a name="stoptime"></a><h4><code>stop(time)</code></h4>
<ul>
<li><code>time</code> <em>(float)</em> time in seconds for unit deactivation. optional.</li>
</ul>
<a name="wxphasor"></a><h2>WX.Phasor</h2>
<p>Phasor implementation based on Chris Roger&#39;s idea of cascaded notch filters.</p>
<a name="wxphasor-parameters"></a><h3>WX.Phasor: Parameters</h3>
<table>
<thead>
<tr>
<th align="center">name</th>
<th align="center">type</th>
<th align="center">description</th>
<th align="center">modulatable</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>pRate</code></td>
<td align="center">float</td>
<td align="center">LFO modulation speed</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>pDepth</code></td>
<td align="center">float</td>
<td align="center">LFO modulation depth</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>pBaseFrequency</code></td>
<td align="center">float</td>
<td align="center">base frequency of filter group</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>pSpacing</code></td>
<td align="center">float</td>
<td align="center">spacing factor for filter frequencies</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>pMix</code></td>
<td align="center">float</td>
<td align="center">mix amount between wet and dry signal</td>
<td align="center"></td>
</tr>
</tbody>
</table>
<a name="wxpingpong"></a><h2>WX.Pingpong</h2>
<p>Stereo ping-pong delay with variable crosstalk between channels.</p>
<a name="wxpingpong-parameters"></a><h3>WX.pingpong: Parameters</h3>
<table>
<thead>
<tr>
<th align="center">name</th>
<th align="center">type</th>
<th align="center">description</th>
<th align="center">modulatable</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>pDelayTimeLeft</code></td>
<td align="center">float</td>
<td align="center">left delay time in seconds</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>pDelayTimeRight</code></td>
<td align="center">float</td>
<td align="center">right delay time in seconds</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>pFeedbackLeft</code></td>
<td align="center">float</td>
<td align="center">feedback amount for left delay channel</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>pFeedbackRight</code></td>
<td align="center">float</td>
<td align="center">feedback amount for right delay channel</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>pCrosstlak</code></td>
<td align="center">float</td>
<td align="center">crosstalk amount</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>pMix</code></td>
<td align="center">float</td>
<td align="center">mix amount between wet and dry signal</td>
<td align="center"></td>
</tr>
</tbody>
</table>
<a name="wxpingpong-methods"></a><h3>WX.pingpong: Methods</h3>
<a name="setdelaytimeleft-right-transtype-time1-time2"></a><h4><code>setDelayTime(left, right, transtype, time1, time2)</code></h4>
<ul>
<li><code>left</code> <em>(float)</em> left delay time in seconds</li>
<li><code>right</code> <em>(float)</em> right delay time in seconds</li>
</ul>
<a name="setfeedbackleft-right-transtype-time1-time2"></a><h4><code>setFeedback(left, right, transtype, time1, time2)</code></h4>
<ul>
<li><code>left</code> <em>(float)</em> feedback amount for left delay channel</li>
<li><code>right</code> <em>(float)</em> feedback amount for right delay channel</li>
</ul>
<a name="wxsampler"></a><h2>WX.Sampler</h2>
<p>Buffer source node abstraction with additional features.</p>
<a name="wxsampler-parameters"></a><h3>WX.Sampler: Parameters</h3>
<table>
<thead>
<tr>
<th align="center">name</th>
<th align="center">type</th>
<th align="center">description</th>
<th align="center">modulatable</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>pPitch</code></td>
<td align="center">int</td>
<td align="center">MIDI pitch for sample playback</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>pBasePitch</code></td>
<td align="center">int</td>
<td align="center">base pitch for sample</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>pLoop</code></td>
<td align="center">boolean</td>
<td align="center">loop mode</td>
<td align="center"></td>
</tr>
</tbody>
</table>
<a name="wxsampler-methods"></a><h3>WX.Sampler: Methods</h3>
<a name="onloadfn"></a><h4><code>onload(fn)</code></h4>
<p>Specifies callback function for sample buffer &#39;onload&#39; event.</p>
<ul>
<li><code>fn</code> <em>(function)</em> function to be executed on sample loaded</li>
</ul>
<a name="setbufferbuffer"></a><h4><code>setBuffer(buffer)</code></h4>
<p>Assigns a sample buffer to sampler.</p>
<ul>
<li><code>buffer</code> <em>(audioBuffer)</em> sample buffer for sampler</li>
</ul>
<a name="getdruation"></a><h4><code>getDruation()</code></h4>
<p>Returns duration of sample buffer in seconds.</p>
<a name="oneshottime-duration"></a><h4><code>oneshot(time, duration)</code></h4>
<p>Starts sample playback at specified time for duration. Useful for <em>trigger and forget</em> approach.</p>
<ul>
<li><code>time</code> <em>(float)</em> function to be executed on sample loaded</li>
<li><code>duration</code> <em>(float)</em> function to be executed on sample loaded</li>
</ul>
<a name="starttime"></a><h4><code>start(time)</code></h4>
<ul>
<li><code>time</code> <em>(float)</em> time in seconds for unit activation. optional.</li>
</ul>
<a name="stoptime"></a><h4><code>stop(time)</code></h4>
<ul>
<li><code>time</code> <em>(float)</em> time in seconds for unit deactivation. optional.</li>
</ul>
<a name="wxsaturator"></a><h2>WX.Saturator</h2>
<p>Implements saturation effect based on WaveShaper node.</p>
<a name="wxsaturator-parameters"></a><h3>WX.Saturator: Parameters</h3>
<table>
<thead>
<tr>
<th align="center">name</th>
<th align="center">type</th>
<th align="center">description</th>
<th align="center">modulatable</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>pQuality</code></td>
<td align="center">float</td>
<td align="center">saturation quality</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>pDrive</code></td>
<td align="center">float</td>
<td align="center">saturation amount</td>
<td align="center"></td>
</tr>
</tbody>
</table>
<a name="wxspectrum"></a><h2>WX.Spectrum</h2>
<p>Spectrum visualizer based on Analyser node.</p>
<a name="wxspectrum-parameters"></a><h3>WX.Spectrum: Parameters</h3>
<table>
<thead>
<tr>
<th align="center">name</th>
<th align="center">type</th>
<th align="center">description</th>
<th align="center">modulatable</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>pSmoothingTimeConstant</code></td>
<td align="center">float</td>
<td align="center">smoothing factor between succesive frames</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>pMaxDecibels</code></td>
<td align="center">float</td>
<td align="center">maximum gain in decibels</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>pMinDecibels</code></td>
<td align="center">float</td>
<td align="center">minimum gain in decibels</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>pScale</code></td>
<td align="center">string</td>
<td align="center">frequency axis scale*</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>pAutoClear</code></td>
<td align="center">boolean</td>
<td align="center">clear drawn visualization every frame</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>pShowGrid</code></td>
<td align="center">boolean</td>
<td align="center">show reference(frequency/decibels) grid</td>
<td align="center"></td>
</tr>
</tbody>
</table>
<ul>
<li>scale: log | linear</li>
</ul>
<a name="wxspectrum-methods"></a><h3>WX.Spectrum: Methods</h3>
<a name="setcontext2dcontext"></a><h4><code>setContext2D(context)</code></h4>
<p>Sets 2d context (canvas) for visualization.</p>
<ul>
<li><code>context</code> <em>(context2d)</em> 2d context from canvas</li>
</ul>
<a name="drawcolor-gridcolor"></a><h4><code>draw(color, gridColor)</code></h4>
<p>Draws visualization and reference grid with color setting. Use inside animation rendering loop.</p>
<ul>
<li><code>color</code> <em>(string)</em> visualization color</li>
<li><code>gridColor</code> <em>(string)</em> reference grid color</li>
</ul>
<a name="wxstep"></a><h2>WX.Step</h2>
<p>Control signal (DC offset) generator. Use with oscillator or envelope to generate modulation source signal.</p>
<a name="wxstep-methods"></a><h3>WX.Step: Methods</h3>
<a name="stoptime"></a><h4><code>stop(time)</code></h4>
<ul>
<li><code>time</code> <em>(float)</em> time in seconds for unit deactivation. optional.</li>
</ul>
<a name="wxstereovisualizer"></a><h2>WX.StereoVisualizer</h2>
<p>Stereo visualizer with user-defined render method.</p>
<a name="wxstereovisualizer-parameters"></a><h3>WX.StereoVisualizer: Parameters</h3>
<table>
<thead>
<tr>
<th align="center">name</th>
<th align="center">type</th>
<th align="center">description</th>
<th align="center">modulatable</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>pSmoothingTimeConstant</code></td>
<td align="center">float</td>
<td align="center">smoothing factor between succesive frames</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>pMaxDecibels</code></td>
<td align="center">float</td>
<td align="center">maximum gain in decibels</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>pMinDecibels</code></td>
<td align="center">float</td>
<td align="center">minimum gain in decibels</td>
<td align="center"></td>
</tr>
</tbody>
</table>
<a name="wxstereovisualizer-methods"></a><h3>WX.StereoVisualizer: Methods</h3>
<a name="drawspectrum"></a><h4><code>drawSpectrum()</code></h4>
<p>Draws frequency-domain visualization with user-defined render method. Use inside animation rendering loop.</p>
<a name="drawwaveform"></a><h4><code>drawWaveform()</code></h4>
<p>Draws time-domain visualization with user-defined render method. Use inside animation rendering loop.</p>
<a name="ondrawfn"></a><h4><code>onDraw(fn)</code></h4>
<p>Defines render algorithm for drawing methods.</p>
<ul>
<li><code>fn</code> <em>(function)</em> function to be executed every animation frame.</li>
</ul>
<a name="ondrawbuffer1-buffer2"></a><h4><code>_ondraw(buffer1, buffer2)</code></h4>
<p>Callback function for frame rendering. Defined by &#39;.onDraw()&#39; method.</p>
<ul>
<li><code>buffer1</code> <em>(Float32Array | Uint8Array)</em> buffer data for left channel</li>
<li><code>buffer2</code> <em>(Float32Array | Uint8Array)</em> buffer data for right channel</li>
</ul>

<a name="license-acknowledgement"></a><h1>License &amp; Acknowledgement</h1>
<a name="license"></a><h2>License</h2>
<p>The MIT License<br>
Copyright (c) 2010-2013 Hongchan Choi</p>
<a name="acknowldegement"></a><h2>Acknowldegement</h2>
<p>Special thanks to Chris Rogers, who invented the world of web audio, for invaluable guidance and feedback. I am also grateful to several Googlers who have been truly supportive on this project: Greg Simon and Dimitri Glazkov, Chris Wilson, and Boris Smus. Lastly, I sincerely thank to my CCRMAlites - Jonathan Berger, Chris Chafe, Ge Wang, John Granzow, Colin Sullivan and Juhan Nam - for their enthusiasm to help me bring new technologies into the computer music.</p>





        </div>
        <footer id="footer">
            Powered by <a href="http://github.com/maximebf/beautiful-docs">beautiful-docs</a> -
            <a href="#top">Back to top</a> - <a href="all.html">Everything on a single page</a>
            - <a href="?print=1">Print current page</a> - <a href="all.html?print=1">Print all pages</a>
            
        </footer>
    </div>
</body>
</html>
