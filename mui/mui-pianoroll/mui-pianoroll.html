<link rel="import" href="../../bower_components/polymer/polymer.html">

<polymer-element name="mui-pianoroll">

<template>

  <style>
    :host {
      /*width: 100%;*/
      display: block;
      overflow: hidden;
      margin-bottom: 5px;
    }
    .container {
      /*width: 100%;*/
      position: relative;
      display: block;
      vertical-align: top;
      overflow: hidden;
    }
    .toolbar {
      display: block;
      height: 28px;
      background-color: #eee;
    }
  </style>

  <div id="eContainer" class="container">
    <div id="eToolbar" class="toolbar"></div>
    <canvas id="eOnScreenCanvas"></canvas>
  </div>

</template>

<script>
  Polymer('mui-pianoroll', {

    _ctx: null,
    _ctxos: null,

    _notelist: null,
    _selectedNotes: [],
    _newNote: null,

    // internal key data strcuture
    _keys: [],

    // current viewpoint's virtual coord
    _cx: 0,
    _cy: 0,

    // area
    _minH: 400,
    _vp: { x: 0, y: 0, w: null, h: null },
    _ruler: { x: 40, y: 0, w: null, h: 23 },
    _kbd: { x: 0, y: 23, w: 40, h: null },
    _grid: { x: 40, y: 23, w: null, h: null },

    // pitchRange (keyboard): C-1 (0) ~ G9 (127)
    _kbdMaxH: 96 * 10 + 64,

    // tiles
    _tile: {
      ruler: { x: 40, y: 0, w: 320, h: 23 },
      kbd: { x: 0, y: 23, w: 40, h: 96},
      grid: { x: 40, y: 23, w: 320, h: 96 }
      // lane: { x: 40, y: 119, w: 320, h: 74 }
    },

    // tick per pixel, pitch per pixel (tick_per_beat = 480)
    _tickPx: (480 * 4) / 320,
    _pitchPx: 12 / 96,
    _pxTick: 320 / (480 * 4),
    _pxPitch: 96 / 12,

    // dirty flag
    _needsRedraw: true,

    //
    // utilities
    //

    _MIDI2Grid: function (note) {
      return {
        x: Math.ceil(note.start * this._pxTick) - this._cx + this._kbd.w,
        y: Math.floor((130 - note.pitch) * this._pxPitch) - this._cy,
        w: Math.floor(note.dur * this._pxTick),
        h: this._pxPitch
      };
    },

    _grid2MIDI: function (data) {
      var nx = this._cx + data.x - this._kbd.w,
          ny = this._cy + data.y - this._ruler.h;
      return {
        pitch: 127 - Math.floor(ny * this._pitchPx),
        tick: Math.round(nx * this._tickPx)
      };
    },

    _grid2MIDIRelative: function (dx, dy) {
      return {
        pitch: dy * this._pitchPx,
        tick: Math.round(dx * this._tickPx)
      };
    },

    _selectNote: function (posMIDI) {
      var note = this._notelist.findNoteAtPosition(posMIDI.pitch, posMIDI.tick);
      if (note && this._selectedNotes.indexOf(note) < 0) {
        this._selectedNotes.push(note);
      }
    },

    _moveSelectedNotes: function (deltaMIDI) {
      for (var i = 0; i < this._selectedNotes.length; i++) {
        var note = this._selectedNotes[i];
        note.pitch = note.pitch + deltaMIDI.pitch;
        note.start = note.start + deltaMIDI.tick;
      }
    },

    _clearNoteSelection: function () {
      this._selectedNotes.length = 0;
    },

    _startNewNote: function (posMIDI) {
      this._newNote = WX.Note(posMIDI.pitch, 100, posMIDI.tick, 60);
      this._notelist.add(this._newNote);
    },

    _updateNewNote: function (posMIDI) {
      var dur = posMIDI.tick - this._newNote.start;
      this._newNote.dur = Math.max(dur, 60);
    },

    _endNewNote: function (posMIDI) {
      this._updateNewNote(posMIDI);
      this._newNote = null;
    },

    _deleteSelectedNotes: function () {
      for (var i = 0; i < this._selectedNotes.length; i++) {
        this._notelist.remove(this._selectedNotes[i]);
      }
    },

    //
    // Drawing related
    //

    _clearCanvas: function () {
      this._ctx.fillStyle = '#222';
      this._ctx.fillRect(0, 0, this._kInnerWidth, this._kInnerHeight);
    },

    _resize: function () {
      // get current host size
      this._kInnerWidth = this.clientWidth;
      this._kInnerHeight =
        this.clientHeight < this._minH ? this._minH : this.clientHeight;
      // adjust canvas size
      this._ctx.canvas.style.width = '100%';
      this._ctx.canvas.width = this._kInnerWidth;
      this._ctx.canvas.height = this._kInnerHeight;
      // adjust key coordinates
      this._vp.w = this._kInnerWidth;
      this._vp.h = this._kInnerHeight;
      this._grid.w = this._kInnerWidth - this._kbd.w;
      this._grid.h = this._kInnerHeight - this._ruler.h;
      this._kbd.h = this._grid.h;
      this._ruler.w = this._grid.w;
    },

    _loadImageMap: function (callback) {
      this._imageMap = new Image();
      this._imageMap.onload = function () {
        callback();
      }.bind(this);
      this._imageMap.src = '/mui/mui-pianoroll/imagemap.png';
    },

    _buildImageMap: function () {
      // for smooth moving, pre-render possible workspace background tiles
      // onto offscreen canvas

      // get rows and cols for tiles with buffer area
      var numCols = Math.round(this._grid.w / this._tile.grid.w) + 2,
          numRows = Math.round(this._grid.h / this._tile.grid.h) + 2;
      var r, c;

      // resize offscreen canvas
      this._ctxos.canvas.width =
        this._tile.kbd.w + numCols * this._tile.grid.w;
      this._ctxos.canvas.height =
        this._tile.ruler.h + numRows * this._tile.grid.h;

      // draw ruler
      for (c = 0; c < numCols; c++) {
        this._ctxos.drawImage(this._imageMap,
          this._tile.ruler.x, this._tile.ruler.y,
          this._tile.ruler.w, this._tile.ruler.h,
          this._tile.ruler.x + c * this._tile.ruler.w, this._tile.ruler.y,
          this._tile.ruler.w, this._tile.ruler.h
        );
        // lane: currently disabled
        // this._ctxos.drawImage(this._imageMap,
        //   this._tile.lane.x, this._tile.lane.y,
        //   this._tile.lane.w, this._tile.lane.h,
        //   this._tile.lane.x + c * this._tile.lane.w,
        //   this._vp.h - this._tile.lane.h,
        //   this._tile.lane.w, this._tile.lane.h
        // );
      };
      // draw kbd
      for (r = 0; r < numRows; r++) {
        this._ctxos.drawImage(this._imageMap,
          this._tile.kbd.x, this._tile.kbd.y,
          this._tile.kbd.w, this._tile.kbd.h,
          this._tile.kbd.x, this._tile.ruler.h + r * this._tile.kbd.h,
          this._tile.kbd.w, this._tile.kbd.h
        );
      }
      // draw grid
      for (r = 0; r < numRows; r++) {
        for (c = 0; c < numCols; c++) {
          this._ctxos.drawImage(this._imageMap,
            this._tile.grid.x, this._tile.grid.y,
            this._tile.grid.w, this._tile.grid.h,
            this._tile.kbd.w + c * this._tile.grid.w,
            this._tile.ruler.h + r * this._tile.grid.h,
            this._tile.grid.w, this._tile.grid.h
          );
        }
      }
    },

    _drawDebug: function () {
      this._ctx.drawImage(this._ctxos.canvas, 0, 0);
    },

    _drawForeground: function () {
      // ruler
      this._ctx.drawImage(this._ctxos.canvas,
        // src
        this._ruler.x + (this._cx % this._tile.ruler.w),
        this._ruler.y,
        this._ruler.w,
        this._ruler.h,
        // dst
        this._ruler.x,
        this._ruler.y,
        this._ruler.w,
        this._ruler.h
      );
      // playhead
      if (this._vp.x <= this._playheadPos &&
        this._playheadPos < this._vp.x + this._vp.w) {
        this._ctx.beginPath();
        this._ctx.moveTo(this._playheadPos, this._vp.y);
        this._ctx.lineTo(this._playheadPos, this._vp.h);
        this._ctx.strokeStyle = '#fff';
        this._ctx.stroke();
      }
      // keyboard (32 is for G8, 127 offset)
      this._ctx.drawImage(this._ctxos.canvas,
        this._kbd.x,
        this._kbd.y + 32 + (this._cy % this._tile.kbd.h),
        this._kbd.w,
        this._kbd.h,
        this._kbd.x,
        this._kbd.y,
        this._kbd.w,
        this._kbd.h
      );
      // corner
      this._ctx.fillStyle = '#222';
      this._ctx.fillRect(0, 0, this._ruler.x, this._kbd.y);
    },

    _drawBackground: function () {
      // grid
      this._ctx.drawImage(this._ctxos.canvas,
        this._grid.x + (this._cx % this._tile.grid.w),
        this._grid.y + (this._cy % this._tile.grid.h),
        this._grid.w,
        this._grid.h,
        this._grid.x,
        this._grid.y,
        this._grid.w,
        this._grid.h
      );
    },

    _drawNotes: function () {
      this._ctx.lineWidth = 1.0;
      this._notelist.iterate(function (idx, note) {
          if (note) {
            // transfrom viewport
            var pos = this._MIDI2Grid(note);
            // filter out invisible notes
            if (this._grid.x + this._grid.w < pos.x) return;
            if (pos.x + pos.w < this._grid.x) return;
            if (this._grid.y + this._grid.h < pos.y) return;
            if (pos.y + pos.h < this._grid.y) return;
            // draw note
            if (this._selectedNotes.indexOf(note) == -1) {
              this._ctx.strokeStyle = '#000';
              this._ctx.fillStyle = '#C66';
            } else {
              this._ctx.strokeStyle = '#fff';
              this._ctx.fillStyle = '#D99';
            }
            this._ctx.strokeRect(pos.x, pos.y, pos.w, pos.h);
            this._ctx.fillRect(pos.x, pos.y, pos.w, pos.h);
            // console.log('drawn', note); // to debug
          }
        }.bind(this)
      );
    },

    _scrollByDelta: function (dx, dy) {
      this._cx -= dx;
      this._cy -= dy;
      // boundary checking
      this._cx = (this._cx < 0) ? 0 : this._cx;
      this._cy = (this._cy < 0) ? 0 : this._cy;
      if (this._cy > this._kbdMaxH - this._grid.h) {
        this._cy = this._kbdMaxH - this._grid.h;
      }
    },

    setPlayhead: function (tick) {
      var pos = Math.ceil(tick * this._pxTick) - this._cx + this._kbd.w;
      if (pos !== this._playheadPos) {
        this._playheadPos = pos;
        this._needsRedraw = true;
      }
    },

    _draw: function () {
      this._clearCanvas();
      this._drawBackground();
      this._drawNotes();
      this._drawForeground();
    },

    update: function () {
      if (this._needsRedraw) {
        this._draw();
        this._needsRedraw = false;
      }
      requestAnimationFrame(this.update.bind(this));
    },

    _listenKeyDown: function (event) {
      if (this._keys[event.keyCode]) return;
      this._keys[event.keyCode] = true;
      // console.log(event.keyCode);
      switch (event.keyCode) {
        case 46: // delete key
          this._deleteSelectedNotes();
      }
      this._needsRedraw = true;
    },

    _listenKeyUp: function (event) {
      if (!this._keys[event.keyCode]) return;
      this._keys[event.keyCode] = false;
    },

    ready: function () {

      // create offscreen canvas
      var offscreen = document.createElement('canvas');

      // create 2d context
      this._ctx = this.$.eOnScreenCanvas.getContext('2d');
      this._ctxos = offscreen.getContext('2d');

      // load+build image map and callback when done
      this._loadImageMap(function () {
        // resize element height to minimum and clear out
        this._resize();
        this._buildImageMap();
        // this._drawDebug();
        this._needsRedraw = true;
        this.update();
      }.bind(this));

      // UI specific vars
      var prevData, uy;

      // mouse responder
      var mouseResponder = MUI.MouseResponder(
        this.label,
        this.$.eOnScreenCanvas,
        function (sender, action, data) {
          switch (action) {
            case 'clicked':
              // note creation
              if (data.altKey) {
                document.body.style.cursor = 'crosshair';
                this._startNewNote(this._grid2MIDI(data));
              }
              // note selection
              if (!data.shiftKey) {
                this._clearNoteSelection();
              }
              // if click selects a note, make selection
              var pos = this._grid2MIDI(data)
              if (pos) {
                this._selectNote(pos);
              }
              // with meta key, scroll the view.
              if (data.metaKey) {
                document.body.style.cursor = 'all-scroll';
              }
              uy = 0;
              this._needsRedraw = true;
              break;
            case 'dragged':
              // creating new note
              if (this._newNote) {
                this._updateNewNote(this._grid2MIDI(data));
                this._needsRedraw = true;
                break;
              }
              // scroll with meta (command key)
              if (data.metaKey) {
                this._scrollByDelta(data.x - prevData.x, data.y - prevData.y);
              }
              // otherwise move selected notes
              else {
                var dx = data.x - prevData.x,
                    dy = 0;
                uy -= data.y - prevData.y;
                // quantizing ux by px per pitch
                if (uy > this._pxPitch || uy < -this._pxPitch) {
                  dy = Math.round(uy / this._pxPitch);
                  uy = uy / this._pxPitch - dy;
                }
                // translate back to screen coord
                dy *= this._pxPitch;
                // move notes
                this._moveSelectedNotes(this._grid2MIDIRelative(dx, dy));
              }
              this._needsRedraw = true;
              break;
            case 'released':
              document.body.style.cursor = 'default';
              if (this._newNote) {
                this._endNewNote(this._grid2MIDI(data));
                this._needsRedraw = true;
              }
              marqueeMode = false;
              break;
          }
          prevData = data;
        }.bind(this)
      );

      // keyboard responder
      window.addEventListener('keydown', this._listenKeyDown.bind(this), false);
      window.addEventListener('keyup', this._listenKeyUp.bind(this), false);
    },

    setNoteList: function (notelist) {
      this._notelist = notelist;
      this.update();
    }

  });
</script>

</polymer-element>