<!DOCTYPE html>
<html>
  <head>
    <link href="static/demos.css" rel="stylesheet" type="text/css">
    <link href="../lib/UI/UI-light.css" rel="stylesheet" type="text/css">
    <style>
      .c-clock {
        background-color: #333;
        width: 400px;
        height: 100px;
        border-radius: 10px;
        color: #3f3;
        font-size: 50px;
        font-family: monospace;
        line-height: 100px;
        text-align: center;
      }
    </style>
  </head>
  <body>

    <div class="c-demohome"><a href="index.html">Index</a></div>
    <h1>Loop Sequencer</h1>
    <div class="c-body-wrapper" id="i-container">
      <canvas id="i-grid"></canvas>
      <div class="c-clock" id="i-clock"></div>
    </div>

    <!-- lib r8 -->
    <script src="../src/core/WAAX.js"></script>
    <script src="../src/core/Utils.js"></script>
    <script src="../src/core/Builtin.js"></script>
    <script src="../src/core/Unit.js"></script>
    <script src="../src/generator/Oscil.js"></script>
    <script src="../src/generator/Fmop.js"></script>
    <script src="../src/generator/Noise.js"></script>
    <script src="../src/generator/ITrain.js"></script>
    <script src="../src/generator/Sampler.js"></script>
    <script src="../src/generator/Step.js"></script>
    <script src="../src/processor/Fader.js"></script>
    <script src="../src/processor/Spatter.js"></script>
    <script src="../src/processor/ADSR.js"></script>
    <script src="../src/processor/Filter.js"></script>
    <script src="../src/processor/Filterbank.js"></script>
    <script src="../src/processor/Formant.js"></script>
    <script src="../src/processor/FormantV.js"></script>
    <script src="../src/processor/Pingpong.js"></script>
    <script src="../src/processor/Chorus.js"></script>
    <script src="../src/processor/Phasor.js"></script>
    <script src="../src/processor/Comp.js"></script>
    <script src="../src/processor/Converb.js"></script>
    <script src="../src/analyzer/Waveform.js"></script>
    <script src="../src/analyzer/Spectrum.js"></script>
    <script src="../src/core/Boot.js"></script>
    <!-- Ktrl -->
    <script src="../lib/Ktrl/Ktrl.js"></script>
    <script src="../lib/UI/UI.js"></script>
    <script src="../lib/UI/UISlider.js"></script>
    <script src="../lib/UI/UIButton.js"></script>
    <script src="../lib/UI/UIIndexedList.js"></script>
    <!-- scripts -->
    <script>

    function Node (lane, time) {
      this.lane = lane;
      this.time = time;
      this.next = null;
      this.selected = false;

      this.select = function (bool) {
        this.selected = bool;
      }
    }

    function OrderedList () {
      this.nodes = [];
      this.last = null;
      this.first = null;
      this.head = null;
      this.read = null; // drawing
      this.read2 = null; // playing
      this.onchange = function () {};
    }

    OrderedList.prototype = {

      createNode: function (lane, time) {
        this.add(new Node(lane, time));
        this.onchange();
      },

      deleteNode: function (node) {
        this.remove(node);
        this.onchange();
      },

      add: function (node) {
        if (this.nodes.length === 0) {
          // if this is the first node
          this.first = node;
          // this.head = this.first;
          // this.read = this.first;
          // this.read2 = this.first;
          this.nodes.push(node);
        } else if (node.time <= this.first.time) {
          // if node is earlier than the first
          node.next = this.first;
          this.first = node;
          this.nodes.push(node);
        } else {
          // otherwise get the shit done
          this._insert(node, this.first);
        }
      },

      _insert: function (node, head) {
        if (head.next) {
          // if head has next, do compare
          if (node.time <= head.next.time) {
            // if node is between head and next
            node.next = head.next;
            head.next = node;
            this.nodes.push(node);
          } else {
            this._insert(node, head.next);
          }
        } else {
          // if head doesn't have next, this is the last
          head.next = node;
          this.nodes.push(node);
        }
      },


        // if (node.time < this.head.time) {
        //   // if this is the earliest node
        //   node.next = this.head;
        //   this.first = node;
        //   this.head = this.first;
        //   this.nodes.push(node);
        //   return;
        // } else {
        //   // if node is somewhere later
        //   if (this.head.next) {
        //     // if next exists
        //     if (node.time < this.head.next.time) {
        //       // if node time is earlier than next time: insert between head and next (DONE)
        //       node.next = this.head.next;
        //       this.head.next = node;
        //       this.head = this.first;
        //       this.nodes.push(node);
        //     } else {
        //       // if node is later than next, advance head and iterate
        //       this.head = this.head.next;
        //       this._insert(node);
        //     }
        //   } else {
        //     // if no next, node will be the last (DONE)
        //     this.head.next = node;
        //     this.head = this.first;
        //     this.nodes.push(node);
        //   }
        // }


      remove: function (node) {
        if (this.first === node) {
          // if node is first
          this.first = this.first.next;
          this.head = this.first;
          this.read = this.first;
          this.read2 = this.first;
          var idx = this.nodes.indexOf(node);
          this.nodes.splice(idx, 1);
        } else {
          // if node is somewhere else
          this._delete(node, this.first);
        }
      },

      _delete: function (node, head) {
        if (node === head.next) {
          // node found and removed
          head.next = head.next.next;
          var idx = this.nodes.indexOf(node);
          this.nodes.splice(idx, 1);
          return true;
        } else {
          if (head.next) {
            // go to next iteration
            this._delete(node, head.next);
          } else {
            // couldn't find, reached the EOL
            return false;
          }
        }
      },

      dump: function () {
        this._printNode(this.first);
      },

      _printNode: function (node) {
        console.log(node.lane, node.time);
        if (node.next) {
          this._printNode(node.next);
        }
      },

      // for drawing
      traverse: function (callback) {
        if (this.first) {
          this._rTraverse(callback, this.first);
        }
      },

      _rTraverse: function (callback, head) {
        callback(head);
        if (head.next) {
          this._rTraverse(callback, head.next);
        }
      },

      getNodeAtPosition: function (time, lane) {
        if (this.first) {
          return this._rGetNodeAtPosition(time, lane, this.first);
        } else {
          return null;
        }
      },

      _rGetNodeAtPosition: function (time, lane, head) {
        if (head.time <= time && time <= head.time + gDur16) {
          if (head.lane === lane) {
            return head;
          }
        }
        if (head.next) {
          return this._rGetNodeAtPosition(time, lane, head.next);
        } else {
          return null;
        }
      },

      // for playing note
      advance: function () {
        if (this.read2.next) {
          this.read2 = this.read2.next;
          return true;
        } else {
          this.read2 = null;
          return false;
        }
      },

      getCurrentNode: function () {
        return this.read2;
      },

      reset: function () {
        this.read2 = this.first;
      },

      onChange: function (fn) {
        this.onchange = fn;
      }

    };

      var cvs = document.getElementById('i-grid');
      var ctx = cvs.getContext('2d');
      var gWidth = 768;
      var gHeight = 320;
      ctx.canvas.width = gWidth;
      ctx.canvas.height = gHeight;

      var divClock = document.getElementById('i-clock');

      var numGridTime = 16 * 2; // 2 bar (8 beats, 32 sixteenth)
      var numGridLane = 16;
      var gridW = gWidth / numGridTime;
      var gridH = gHeight / numGridLane;
      var gPlayhead = 0.0;



      var gBPM = 120.0;
      var gDur4 = 60 / gBPM;
      var gDur8 = gDur4 / 2;
      var gDur16 = gDur8 / 2;
      var gDur32 = gDur16 / 2;
      var gDurTick = gDur4 / 96; // MPC convention
      var gLoopDuration = gDur4 * 8; // 2 bars
      var gLookAhead = gDurTick * 10; // look ahead for 10 tick

      var gOrigin = WX.now;
      var gEnd = WX.now + gLoopDuration;
      var gNow = 0.0;

      var bPlayback = false;
      var gReader = 0;


      var uMetroFader = WX.Fader();
      uMetroFader.to(WX.DAC);

      var ply = new Player();

      // build buffermap
      WX.buildBufferMap(
        {
          payload: {
            'ASRX KD1': '../data/PADS-10/asrx/ASR-X Kick 03.wav',
            'ASRX KD2': '../data/PADS-10/asrx/ASR-X Kick 11.wav',
            'ASRX KD3': '../data/PADS-10/asrx/ASR-X Kick 12.wav',
            'ASRX SD1': '../data/PADS-10/asrx/ASR-X Snare 03.wav',
            'ASRX SD2': '../data/PADS-10/asrx/ASR-X Snare 15.wav',
            'ASRX SD3': '../data/PADS-10/asrx/ASR-X Snare 23.wav',
            'ASRX HH1': '../data/PADS-10/asrx/ASR-X Hat 02.wav',
            'ASRX HH2': '../data/PADS-10/asrx/ASR-X Hat 03.wav',
            'ASRX HH3': '../data/PADS-10/asrx/ASR-X Hat 06.wav',
            'ASRX Cym': '../data/PADS-10/asrx/ASR-X Crash 1.wav',
            'Hip KD': '../data/PADS-10/mpc2000/HIP_KICK.wav',
            '808 Long KD': '../data/PADS-10/mpc2000/808_LNG_KICK.wav',
            'Hip SD': '../data/PADS-10/mpc2000/HIP_S_SN.wav',
            'Hip SD7': '../data/PADS-10/mpc2000/HIP_SN_7.wav',
            'Clap': '../data/PADS-10/mpc2000/F_CLAP_1.wav',
            'Rim': '../data/PADS-10/mpc2000/P_SN_RIM.wav'
          }
        },
        function (buffermap) {
          _metroBufferMap = buffermap;
          ply.setBufferMap(buffermap);
          console.log("done.");
        },
        function (progress) {
          console.log("loading...");
        }
      );

      // beat, sixteenth ====> THIS SHOULD BE LINKED LIST....
      var gData = [];
      var gData2 = {};
      for (var i = 0; i < 32; i++) {
        gData[i] = [~~(Math.random()*15.9), i * gDur16];
      }
      gData.sort(function (a, b) {
        return a[1] - b[1];
      });

      var gEventList = new OrderedList();
      // for (var i = 0; i < 32; i++) {
      //   gEventList.createNode(~~(Math.random()*15.9), i * gDur16);
      // }
      //gEventList.dump();

      function drawGrid () {

        // background
        ctx.fillStyle = "#333";
        ctx.fillRect(0, 0, gWidth, gHeight);

        // grid
        ctx.beginPath();
        ctx.strokeStyle = "#444";
        for (var i = 0; i < numGridLane; i++) {
          ctx.moveTo(0, gridH * i);
          ctx.lineTo(gWidth, gridH * i);
        }
        ctx.stroke();

        ctx.beginPath();
        ctx.strokeStyle = "#444";
        for (var i = 0; i < numGridTime; i++) {
          if (i % 4) {
            ctx.moveTo(i * gridW, 0);
            ctx.lineTo(i * gridW, gHeight);
          }
        }
        ctx.stroke();

        ctx.beginPath();
        ctx.strokeStyle = "#888";
        for (var i = 0; i < numGridTime; i++) {
          if (i % 4 === 0) {
            ctx.moveTo(i * gridW, 0);
            ctx.lineTo(i * gridW, gHeight);
          }
        }
        ctx.stroke();
      }

      function drawNote (note) {
        // note[0] = lane, note[1] = time
        var pos = note[1] / gLoopDuration * gWidth;
        var dur = gDur16 / gLoopDuration * gWidth;
        ctx.strokeStyle = "#000";
        ctx.fillStyle = "#C66";
        ctx.strokeRect(pos + 2, note[0] * gridH + 2, dur - 4, gridH - 4);
        ctx.fillRect(pos + 2, note[0] * gridH + 2, dur - 4, gridH - 4);
      }

      function drawNode (node) {
        // note[0] = lane, note[1] = time
        var pos = node.time / gLoopDuration * gWidth;
        var dur = gDur16 / gLoopDuration * gWidth;
        if (node.selected) {
          ctx.strokeStyle = "#FFF";
        } else {
          ctx.strokeStyle = "#000";
        }
        ctx.fillStyle = "#C66";
        ctx.strokeRect(pos + 2, node.lane * gridH + 2, dur - 4, gridH - 4);
        ctx.fillRect(pos + 2, node.lane * gridH + 2, dur - 4, gridH - 4);
      }

      function drawAllNote () {
        gEventList.traverse(drawNode)
        // for (var i = 0; i < gData.length; i++) {
        //   drawNote(gData[i]);
        // }
      }

      function drawPlayhead () {
        var pos = gNow / gLoopDuration * gWidth;
        ctx.beginPath();
        ctx.strokeStyle = "#FFF";
        ctx.moveTo(pos, 0);
        ctx.lineTo(pos, gHeight);
        ctx.stroke();
      }

      function checkLoopBound () {
        if (WX.now > gEnd) {
          gOrigin = gEnd;
          gEnd = gOrigin + gLoopDuration;
          //gReader = 0;
          gEventList.reset();
        }
        gNow = WX.now - gOrigin;
      }

      function lookAheadAndSchedule () {
        // if (gReader < gData.length) {
        //   var note = gData[gReader];
        //   if (note[1] < gNow + gLookAhead) {
        //     // increase
        //     gReader++;
        //     // schedule note
        //     ply.play(note[0], gOrigin + note[1]);
        //     // and recurse
        //     lookAheadAndSchedule();
        //   }
        // }
        var node = gEventList.getCurrentNode();
        if (node) {
          if (node.time < gNow + gLookAhead) {
            ply.play(node.lane, gOrigin + node.time);
            if (gEventList.advance()) {
              lookAheadAndSchedule();
            }
          }
        }
      }

      function update () {
        checkLoopBound();
        lookAheadAndSchedule();
        divClock.textContent = gNow.toFixed(4);
        drawGrid();
        drawAllNote();
        drawPlayhead();
        if (bPlayback) {
          requestAnimationFrame(update);
        }
      }

      divClock.textContent = gNow.toFixed(4);
      drawGrid();
      drawAllNote();
      drawPlayhead();

      gEventList.onChange(function () {
        drawGrid();
        drawAllNote();
      });

      function start () {
        gOrigin = WX.now;
        gEnd = WX.now + gLoopDuration;
        gNow = WX.now - gOrigin;
        bPlayback = true;
        // gReader = 0;
        gEventList.reset();
        update();
      }

      function stop () {
        bPlayback = false;
      }




      // sampler
      function Player (time) {

        this.setBufferMap = function (buffermap) {
          this._bufferMap = buffermap;
          this._buffer = this._bufferMap.getBufferByIndex(0);
        }

        this.setBufferByName = function (name) {
          this._buffer = this._bufferMap.getBufferByName(name);
        }

        this.play = function (lane, time) {
          var source = WX.context.createBufferSource();
          var volume = WX.context.createGain();
          source.connect(volume);
          volume.connect(uMetroFader._inlet);

          source.buffer = this._bufferMap.getBufferByIndex(lane);
          volume.gain.setValueAtTime(1.0, time);
          source.start(time);
          source.stop(time + source.buffer.duration);
        }
      }

      // UI
      var sec_control = UI.ControlCenter.createSection("Control", "i-container");
      var btn_playback = UI.ControlCenter.createControl({
        type: "button", name: "Play", value: false, mode: "toggle"
      }, sec_control);
      var btn_quantize = UI.ControlCenter.createControl({
        type: "button", name: "Quantize", value: false, mode: "toggle"
      }, sec_control);
      var sli_tempo = UI.ControlCenter.createControl({
        type: "slider", name: "Tempo", value: gBPM, min: 30.0, max: 240.0,
        precision: 2, scale: "linear", unit: "bpm"
      }, sec_control);

      btn_playback.addAction(function (value) {
        if (value) {
          start();
        } else {
          stop();
        }
      });
      btn_quantize.addAction(function (value) {
        bQuantize = value;
      });

      sli_tempo.addAction(function (value) {
        // var factor = gBPM / value;
        // gOrigin *= factor;
        // gBPM = value;
        // gGrid4 = 60 / gBPM;
        // gGrid1 = gGrid4 * 4;
        // gGrid16 = gGrid4 * 0.25;
        // gGridTick = gGrid16 / 480;
      });




      // MIDI routing
      var gTestTarget = Ktrl.createTarget("test");
      gTestTarget.onData(function (midimessage) {
        var data = Ktrl.parse(midimessage);
        switch (data.type) {
        }
      });

      Ktrl.ready(function () {
        Ktrl.routeAllToTarget(gTestTarget);
        gTestTarget.activate();
      });

      // interaction
      var gLeft = cvs.getBoundingClientRect().left;
      var gTop = cvs.getBoundingClientRect().top;
      var gSelectedNodes = [];
      cvs.addEventListener("mousedown", function (event) {

        var x = event.clientX - gLeft;
        var y = event.clientY - gTop;
        var time = x / gWidth * gLoopDuration;
        var quanitzed = ~~(time / gDur16) * gDur16;
        var lane = ~~(y / gHeight * 16);

        if (event.shiftKey) {
          // get node
          var node = gEventList.getNodeAtPosition(time, lane);
          // if node is selected
          if (node) {
            if (gSelectedNodes.indexOf(node) === -1) {
              node.select(true);
              gSelectedNodes.push(node);
            }
          }
        } else {
          // without shift key
          // empty selection buffer
          // reset all selected node to deselect them
          gSelectedNodes.map(function (node) {
            node.select(false);
          });
          gSelectedNodes.length = 0;
          // get node
          var node = gEventList.getNodeAtPosition(time, lane);
          if (node) {
            // if node selected
            if (gSelectedNodes.indexOf(node) === -1) {
              node.select(true);
              gSelectedNodes.push(node);
            }
          } else {
            // if no node is selected, create new node
            gEventList.createNode(lane, quanitzed);
          }
        }

        drawGrid();
        drawAllNote();
        drawPlayhead();

      });

      window.addEventListener("keydown", function (event) {
        event.preventDefault();
        //console.log(event.keyCode);
        switch (event.keyCode) {
          // delete key
          case 8:
            if (gSelectedNodes.length > 0) {
              gSelectedNodes.map(function (node) {
                gEventList.deleteNode(node);
              });
              gSelectedNodes.length = 0;
            }
            break;
          // space bar
          case 32:
            bPlayback = !bPlayback;
            btn_playback.setValue(bPlayback);
            break;
        }
      });



    </script>
  </body>
</html>