<!DOCTYPE html>
<html>
  <head>
  </head>
  <body>
    <h1>Dev Mode r8</h1>    
    <!-- lib r8 -->   
    <script src="../src/core/Monkey.js"></script>
    <script src="../src/core/WAAX.js"></script>
    <script src="../src/core/Utils.js"></script>
    <script src="../src/core/Builtin.js"></script>
    <script src="../src/core/Unit.js"></script>
    <script src="../src/generator/Oscil.js"></script>
    <script src="../src/generator/Fmop.js"></script>
    <script src="../src/generator/Noise.js"></script>
    <script src="../src/generator/ITrain.js"></script>
    <script src="../src/generator/Sampler.js"></script>
    <script src="../src/generator/Step.js"></script>
    <script src="../src/processor/Fader.js"></script>
    <script src="../src/processor/Spatter.js"></script>
    <script src="../src/processor/ADSR.js"></script>
    <script src="../src/processor/Filter.js"></script>
    <script src="../src/processor/Formant.js"></script>
    <script src="../src/processor/FormantV.js"></script>
    <script src="../src/processor/Pingpong.js"></script>
    <script src="../src/processor/Chorus.js"></script>
    <script src="../src/processor/Phasor.js"></script>
    <script src="../src/processor/Comp.js"></script>
    <script src="../src/processor/Converb.js"></script>
    <script src="../src/analyzer/Waveform.js"></script>
    <script src="../src/analyzer/Spectrum.js"></script>
    <script src="../src/ktrl/Streamer.js"></script>
    <script src="../src/core/Boot.js"></script>
    
    <!-- test code -->
    <script>

/**
 * Ktrl
 * @namespace
 */
Ktrl = (function() {
  // private vars
  var sources = [];
  var targets = [];

  // parse utility
  parse = function (midimsg) {
    var data = midimsg.data;
    switch (data[0] >> 4) {
      case 9:
        return ["ON", data[1], data[2]];
        break;
      case 8:
        return ["OFF", data[1], data[2]];
        break;
      case 11:
        return ["CC", data[1], data[2]];
        break;
      case 13:
        return ["AF", data[1]];
        break;
      case 14:
        return ["PW", data[1] * data[2]];
        break;
    }
  };

  // report available port
  report = function () {
    var counter = 0;
    console.log("# Available MIDI Input Ports...");
    sources.map(function (s) {
      console.log(s.input.type, counter++, "\t", s.input.name, "\t", s.input.manufacturer);
    });
  };
  
  // class source
  Source = function (midiinput) {
    this.input = midiinput;
    this.targets = [];
    var me = this;
    this.onmidimessage = function (e) {
      for(var i = 0; i < me.targets.length; ++i) {
        me.targets[i].onmidimessage(e);
      }
    };
    this.initialize();
  };
  // class source prototype
  Source.prototype = {
    removeTarget: function (target) {
      // traverse array looking for the target and remove
      for(var i = 0; i < this.targets.length; ++i) {
        if (this.targets[i] === target) {
          var t = this.targets.indexOf(target);
          this.targets.splice(t, 1);
        }
      }
    },
    addTarget: function (target) {
      // if target already exists, ignore
      for(var i = 0; i < this.targets.length; ++i) {
        if (this.targets[i] === target) {
          return;
        }
      }
      this.targets.push(target);
    },
    initialize: function() {
      this.input.onmidimessage = this.onmidimessage;
    }
  };

  /**
   * Target: midi data receiving end
   * @param  {int} ID unique target ID
   */
  Target = function (ID) {
    this.id = ID;
    targets.push(this);
  }
  // class target prototype
  Target.prototype.onmidimessage = function(e) {};

  var counter = 0;
  createTarget = function () {
    return new Target(counter++);
  }

  // ready
  var onReady = null;
  ready = function (fn) {
    if (typeof fn !== 'function') {
      console.log("[ktrl] invalid handler function.");
    } else {
      onReady = fn;
    }
  }
  
  // scan input port and boot up
  navigator.requestMIDIAccess().then(function (midiAccess) {
    // check
    if (midiAccess.inputs().length === 0) {
      console.log("[ktrl] no input ports available");
      return;
    }
    // creating MIDI sources
    for(var i = 0; i < midiAccess.inputs().length; ++i) {
      sources[i] = new Source(midiAccess.inputs()[i]);
    }
    console.log("[ktrl] Ktrl is ready.");
    if (onReady) {
      onReady();
    } else {
      console.log("[ktrl] onReady is not specified.");
    }
  }, function (msg) {
    console.log("[ktrl] failed to get MIDI access: " + msg);
    return;
  });

  // expose stuffs
  return {
    Sources: sources,
    Targets: targets,
    createTarget: createTarget,
    parse: parse,
    report: report,
    ready: ready
  };
})();


// synth1 -----------------------------------------------
var s1 = WX.Oscil({ type: "saw", detune:-5 }),
    s2 = WX.Oscil({ type: "saw", detune:3 }),
    env = WX.ADSR(),
    cmp = WX.Comp({ threshold:-12, ratio:8, makeup:0 }),
    vrb = WX.Converb({ source:"../data/ir/small.wav", mix:0.5 });

// connection
s1.to(env).to(cmp).to(vrb).to(WX.DAC);
s2.to(env);
env.adsr(0.0001, 0.005, 0.8, 0.05);
// setup MIDI target
var mySynth1 = Ktrl.createTarget();
mySynth1.onmidimessage = function (e) {
  var d = Ktrl.parse(e);
  switch(d[0]) {
    case "ON":
      var fund = WX.pitch2freq(d[1]);
      var peak = d[2] / 127;
      s1.freq(fund * 2);
      s2.freq(fund);
      env.gain(peak);
      env.noteOn();
      break;
    case "OFF":
      env.noteOff();
      break;
  }
}

// synth2 -----------------------------------------------
var d1 = WX.Sampler({ source:"../data/samples/kick-0.wav"}),
    d2 = WX.Sampler({ source:"../data/samples/snare-0.wav"}),
    d3 = WX.Sampler({ source:"../data/samples/hihat-0.wav"}),
    d4 = WX.Sampler({ source:"../data/samples/fillin.wav"}),
    d5 = WX.Sampler({ source:"../data/samples/kick-1.wav"}),
    d6 = WX.Sampler({ source:"../data/samples/snare-1.wav"}),
    d7 = WX.Sampler({ source:"../data/samples/hihat-1.wav"}),
    d8 = WX.Sampler({ source:"../data/samples/cleangtr.wav"}),
    cmp2 = WX.Comp({ threshold:-12, ratio:8, makeup:6 });
d1.to(cmp2);
d2.to(cmp2);
d3.to(cmp2);
d4.to(cmp2);
d5.to(cmp2);
d6.to(cmp2);
d7.to(cmp2);
d8.to(cmp2);
cmp2.to(WX.DAC);

// setup MIDI target
var mySynth2 = Ktrl.createTarget();
var selected = null;
mySynth2.onmidimessage = function (e) {
  var d = Ktrl.parse(e);
  console.log(d);
  switch (d[0]) {
    case "ON":
      var velo = Math.pow(d[2]/127, 2.8);
      switch (d[1]) {
        case 48:
          selected = d1;
          d1.gain(velo, WX.now+0.02, "l");
          d1.start(60).stop(WX.now+5.0);
          break;
        case 52:
          selected = d3;
          d3.gain(velo, WX.now+0.02, "l");
          d3.start(60).stop(WX.now+1.0);
          break;
        case 54:
          selected = d2;  
          d2.gain(velo, WX.now+0.02, "l");
          d2.start(60).stop(WX.now+1.0);
          break;
        case 58:
          selected = d4;
          d4.gain(velo, WX.now+0.02, "l");
          d4.start(60).stop(WX.now+1.0);
          break;
        case 49:
          selected = d5;
          d5.gain(velo, WX.now+0.02, "l");
          d5.start(60).stop(WX.now+3.0);
          break;
        case 51:
          selected = d6;
          d6.gain(velo, WX.now+0.02, "l");
          d6.start(60).stop(WX.now+1.0);
          break;
        case 68:
          selected = d7;  
          d7.gain(velo, WX.now+0.02, "l");
          d7.start(60).stop(WX.now+1.0);
          break;
        case 56:
          selected = d8;
          d8.gain(velo, WX.now+0.02, "l");
          d8.start(60).stop(WX.now+1.0);
          break;
      }
      break;
    case "CC":
      switch (d[1]) {
        case 20:
          if (selected) {
            selected.basePitch(~~((1.0 - d[2]/127) * 24) + 48);  
          }
          break;
      }
      break;
  }
}

// onReady --------------------------------------------
Ktrl.ready(function () {
  Ktrl.report();
  // two midi sources into synth1
  // Ktrl.Sources[1].addTarget(mySynth1);
  Ktrl.Sources[3].addTarget(mySynth1);
  // source #1 to synth2
  Ktrl.Sources[1].addTarget(mySynth2);
});

    </script>
  </body>
</html>